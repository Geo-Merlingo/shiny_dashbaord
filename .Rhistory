format(TNZ_trap$record_dat, "%m") %in% c("03", "04", "05"), "Autumn",
ifelse(format(TNZ_trap$record_dat, "%m") %in% c("06", "07", "08"), "Winter",
ifelse(format(TNZ_trap$record_dat, "%m") %in% c("09", "10", "11"), "Spring",
"Summer")
)
)
# Add a months column
TNZ_trap$Month <- format(TNZ_trap$record_dat, "%B")
#Order months by the calendar
TNZ_trap$Month <- factor(TNZ_trap$Month, levels = month.name)
#Filter to catches by selecting all char values not c('NA', 'None', 'Unspecified', "")
TNZ_trap %>%
filter(!(species_ca %in% c('NA', 'None', 'Unspecified'))) -> TNZ_catches2020
#reduce TNZ_trap data to selected cols
TNZ_reduced_whole <-TNZ_trap %>%
select(project, species_ca,trap_type, bait_at_de, line, record_dat, Month,trap_id, Season)
#reduce TNZ_catches2020 data to selected cols
TNZ_catches_reduced <-TNZ_catches2020 %>%
select(project, species_ca,trap_type, bait_at_de, line, record_dat, Month,trap_id, Season)
# Rename data columns to merge with CIT_reduced_whole
TNZ_reduced_whole <- TNZ_reduced_whole %>%
rename(Species = species_ca, Area= project,Trap_type = trap_type, Bait=bait_at_de, Line=line, Date=record_dat)
# Rename data columns to merge with CIT_catches_reduced
TNZ_catches_reduced <- TNZ_catches_reduced %>%
rename(Species = species_ca, Area= project,Trap_type = trap_type, Bait=bait_at_de, Line=line, Date=record_dat)
#add some code here to select the correct col for bait, as there is bait at arrival and if not re baited then this bait persists, but is not captured by current selection.
# #transform projection so both match
# TNZ_reduced_whole <- st_transform(TNZ_reduced_whole, crs =2193 )
#
# #transform projection so both match
# TNZ_catches_reduced <- st_transform(TNZ_catches_reduced, crs =2193 )
#st_crs(CIT_reduced)  # Should now show EPSG:2193
#st_crs(TNZ_catcthes_reduced)  # Should now show EPSG:2193
TNZ_reduced_whole$trap_id <- as.character(TNZ_reduced_whole$trap_id)
TNZ_catches_reduced$trap_id <- as.character(TNZ_catches_reduced$trap_id)
#--------------------------------------------------------------------------------
#Bind rows
#bind whole 24 sets
All_traps <- bind_rows(TNZ_reduced_whole, CIT_reduced_whole)
#bind catches subsets
All_catches <- bind_rows(TNZ_catches_reduced, CIT_catches_reduced)
#--------------------------------------------------------------------------------
#filter to date frames:
#since 2020, since 2021, since 2022, since 2023, since 2024,since begginning of 2025, last 90 days, last 30 days, since beggining of the month.
#Filter to data frames for both catches and all traps
#get todays date
today <- Sys.Date()
print(today)
# Define date filters (rolling and fixed starts)
date_filters <- list(
since_2020     = as.Date("2020-01-01"),
since_2021     = as.Date("2021-01-01"),
since_2022     = as.Date("2022-01-01"),
since_2023     = as.Date("2023-01-01"),
since_2024     = as.Date("2024-01-01"),
since_2025     = as.Date("2025-01-01"),
last_90_days   = Sys.Date() - 90,
last_30_days   = Sys.Date() - 30,
this_month     = as.Date(format(Sys.Date(), "%Y-%m-01"))
)
# Initialize totals
catch_totals   <- list()
record_totals  <- list()
trap_totals    <- list()
All_traps_df <- All_traps %>% st_drop_geometry()
All_catches_df <- All_catches #%>% st_drop_geometry()
# Loop
for (name in names(date_filters)) {
date_val <- date_filters[[name]]
# Filter
catches_df <- All_catches_df %>% filter(Date >= date_val)
traps_df   <- All_traps_df   %>% filter(Date >= date_val)
# Assign filtered catches if needed
assign(paste0("catches_", name), catches_df)
# Count totals
catch_totals[[name]]  <- nrow(catches_df)
record_totals[[name]] <- nrow(traps_df)
trap_totals[[name]]   <- traps_df %>% distinct(trap_id) %>% nrow()
}
# Assemble summary
summary_df <- tibble(
filter_name     = names(date_filters),
total_catches   = unlist(catch_totals),
total_records   = unlist(record_totals),
total_traps     = unlist(trap_totals)
)
print(summary_df)
#------------------------------------------------------------------------------------------------
#in year calcs
# Define years you want to include
years <- 2020:2025
# Create a new list for in_year filters
in_year_filters <- list()
for (y in years) {
in_year_filters[[paste0("in_", y)]] <- list(
start = as.Date(paste0(y, "-01-01")),
end = as.Date(paste0(y, "-12-31"))
)
}
# Initialize output lists
in_year_catch_totals  <- list()
in_year_record_totals <- list()
in_year_trap_totals   <- list()
# Loop through in_year filters
for (name in names(in_year_filters)) {
range <- in_year_filters[[name]]
start_date <- range$start
end_date <- range$end
catches_df <- All_catches_df %>% filter(Date >= start_date, Date <= end_date)
traps_df   <- All_traps_df   %>% filter(Date >= start_date, Date <= end_date)
in_year_catch_totals[[name]]  <- nrow(catches_df)
in_year_record_totals[[name]] <- nrow(traps_df)
in_year_trap_totals[[name]]   <- traps_df %>% distinct(trap_id) %>% nrow()
}
# Assemble the summary table
in_year_summary_df <- tibble(
filter_name   = names(in_year_filters),
total_catches = unlist(in_year_catch_totals),
total_records = unlist(in_year_record_totals),
total_traps   = unlist(in_year_trap_totals)
)
print(in_year_summary_df)
#-----------------------------------------------------------------------------------------------------
# Do calculations:
#sum trap records
CIT_trap_records_l<-length(CIT_trap[[1]])
TNZ_trap_records_l<-length(TNZ_trap[[1]])
#all trap records
total_trap_record_length=CIT_trap_records_l+TNZ_trap_records_l
message((total_trap_record_length), " total trap records")
#Percent from each:
TNZ_trap_percent <- (TNZ_trap_records_l/total_trap_record_length)*100
message((TNZ_trap_percent), " TrapNZ Percent ")
CIT_trap_percent <- (CIT_trap_records_l/total_trap_record_length)*100
message((CIT_trap_percent), " CIT Percent ")
#---------------------------------------------------------------------------------
# Years to process
years <- 2020:2025
# Define rat alias grouping
rat_aliases <- c('Rat - Ship', 'Rat - Norway', 'Ship Rat', 'Norway Rat', 'Rat')
mustelids <- c('Stoat', 'Ferret', 'Weasel')
# Loop through each year
for (y in years) {
df_name <- paste0("catches_since_", y)
df <- get(df_name)
# Clean species names
df <- df %>%
mutate(Species = case_when(
Species %in% rat_aliases ~ 'Rat',
TRUE ~ Species
))
# Update the cleaned data frame in environment
assign(df_name, df)
# Filter and count species
rats <- df %>% filter(Species == 'Rat')
possums <- df %>% filter(Species == 'Possum')
musts <- df %>% filter(Species %in% mustelids)
# Save as summary variables
assign(paste0("rats_", y, "_VAR"), nrow(rats))
assign(paste0("possums_", y, "_VAR"), nrow(possums))
assign(paste0("mustelids_", y, "_VAR"), nrow(musts))
}
#----------------------------------------------------------------------------------
#Prespare for mapping my filtering to target species
# #need to filter to these for Map
# reduced_catches_since_2020 <- catches_since_2020 %>%
#   filter(
#     (Species =='Rat' |
#        Species == 'Possum' |
#        Species == 'Stoat' |
#        Species == 'Ferret' |
#        Species == 'Weasel'|
#        Species == 'Rabbit'|
#        Species == 'Hedgehog'|
#        Species == 'Mouse'
#     )
#   )
#
#
# #order highest to lowest
# # Step 1: Compute species counts and sort
# species_counts <- reduced_catches_since_2020 %>%
#   count(Species) %>%  # Count occurrences of each species
#   arrange(desc(n))  # Sort by highest count
#
#
# # Step 2: Convert `Species` to a factor, ordered by count
# reduced_catches_since_2020 <- reduced_catches_since_2020 %>%
#   mutate(Species = factor(Species, levels = species_counts$Species))
#
# catches_count <- reduced_catches_since_2020 %>%
#   group_by(geometry, Species) %>%  # Group by location & species
#   summarise(Count = n(), .groups = "drop")  # Count occurrences
# Define years and species to include on maps
years <- 2020:2025
map_species <- c('Rat', 'Possum', 'Stoat', 'Ferret', 'Weasel', 'Rabbit', 'Hedgehog', 'Mouse')
for (y in years) {
# Step 1: Get the original sf object
df_name <- paste0("catches_since_", y)
df <- get(df_name)
# Step 2: Filter to key species
reduced_df <- df %>%
filter(Species %in% map_species)
# Step 3: Compute species counts and relevel Species as a factor
species_counts <- reduced_df %>%
count(Species) %>%
arrange(desc(n))
reduced_df <- reduced_df %>%
mutate(Species = factor(Species, levels = species_counts$Species))
# Step 4: Create grouped count by geometry
grouped_counts <- reduced_df %>%
group_by(geometry, Species) %>%
summarise(Count = n(), .groups = "drop")
# Save the outputs with appropriate names
assign(paste0("reduced_catches_since_", y), reduced_df)
assign(paste0("species_counts_", y), species_counts)
assign(paste0("catches_count_", y), grouped_counts)
}
#for testing one map
catches_count<-catches_count_2020
#-----------------------------------------------------------------
#Mapping 'reduced_catches_since_2020'
# for (y in 2020:2025) {
#   message("Processing year: ", y)
#
#   # Step 1: Get data
#   catches_count <- get(paste0("catches_count_", y))
#removed this here as a work around to remove warnings re crs type for funtion
# catches_count <- st_transform(catches_count, crs = 4326)
# Extract Longitude and Latitude
catches_count <- catches_count %>%
mutate(Longitude = st_coordinates(.)[,1],  # Extract Longitude (X)
Latitude = st_coordinates(.)[,2])   # Extract Latitude (Y)
# Create a color palette based on species
pal <- colorFactor(palette = "viridis", domain = catches_count$Species)
# High-contrast color palette
pal <- colorFactor(palette = "Dark2", domain = catches_count$Species)
# Example: Color based on a numeric or categorical variable (replace "YourAttribute" with an actual column)
pal_areas <- colorFactor(palette = "Set1", domain = areas$CustomerNa)
hex_size <- (st_bbox(areas)[4] - st_bbox(areas)[2]) / 50  # 100 hexagons fit in latitude range
sf_use_s2(FALSE)
areas <- st_make_valid(areas)
# Step 1: Create a hexagonal grid over the study area
hex_grid <- st_make_grid(areas, cellsize = hex_size, what = "polygons", square = FALSE)
# Step 2: Convert to sf object and give each hex an ID
hex_grid <- st_sf(hex_id = 1:length(hex_grid), geometry = hex_grid)
# Step 3: Clip hexagons to fit inside study area
hex_grid <- st_intersection(hex_grid, areas)
# Step 4: Ensure hex grid has same CRS as catch points
hex_grid <- st_transform(hex_grid, crs = st_crs(catches_count))
# Step 5: Assign each catch point to the nearest hexagon
nearest_hex <- st_nearest_feature(catches_count, hex_grid)
catches_count$hex_id <- hex_grid$hex_id[nearest_hex]
# Optional check: total count before aggregation
sum(catches_count$Count)
# Step 6: Aggregate counts by hex + species
hex_counts <- catches_count %>%
group_by(hex_id, Species) %>%
summarise(Species_Count = sum(Count, na.rm = TRUE), .groups = "drop") %>%
st_drop_geometry()
# Check: does the sum look right?
sum(hex_counts$Species_Count)
# Diagnostic: check for duplicate hex_id rows (likely caused by geometry intersections)
hex_grid %>%
count(hex_id) %>%
filter(n > 1) -> check
# 🛠️ Fix: Deduplicate hex_grid so that each hex_id is unique (important before joining)
hex_grid_union <- hex_grid %>%
group_by(hex_id) %>%
summarise(geometry = st_union(geometry), .groups = "drop")
# Reproject to projected CRS for safe union
# hex_grid_union <- hex_grid %>%
#   st_transform(2193) %>%
#   group_by(hex_id) %>%
#   summarise(geometry = st_union(geometry), .groups = "drop") %>%
#   st_transform(4326)  # Return to WGS84 for leaflet
# Step 7: Pivot counts wider to make one row per hex
hex_counts_wide <- hex_counts %>%
pivot_wider(names_from = Species, values_from = Species_Count, values_fill = 0)
# Step 8: Join counts back to hex grid (now with one row per hex_id)
hex_grid_final <- hex_grid_union %>%
left_join(hex_counts_wide, by = "hex_id")
# Step 9: Calculate total species per hex (cleaner column selection)
species_cols <- intersect(
c("Rat", "Mouse", "Possum", "Weasel", "Stoat", "Ferret", "Hedgehog", "Rabbit"),
names(hex_grid_final)
)
hex_grid_final <- hex_grid_final %>%
rowwise() %>%
mutate(Total_Species = sum(c_across(all_of(species_cols)), na.rm = TRUE)) %>%
ungroup()
# check species total hasn't changed
sum(hex_grid_final$Total_Species)  # This should now match `sum(hex_counts$Species_Count)`
# Ensure Total_Species is calculated
hex_grid_final <- hex_grid_final %>%
mutate(Total_Species = ifelse(is.na(Total_Species), 0, Total_Species))
# Step 1: Define your grading template
grade_template <- c(0, 1, 20, 100, 300)
# Step 2: Compute per-year max
max_val <- max(hex_grid_final$Total_Species, na.rm = TRUE)
if (max_val == 0) max_val <- 1  # safeguard
# Step 3: Extend the grading template to fit max, without collapsing bins
adjusted_max <- if (max_val <= max(grade_template)) max(grade_template) + 1 else max_val + 1
# Step 4: Final bins, ensuring monotonicity
bins <- unique(c(grade_template[grade_template < adjusted_max], adjusted_max))
# Step 5: Build palette
pal_hex <- colorBin(
palette = c("#A9A9A9", "yellow", "orange", "red", "darkred")[1:(length(bins) - 1)],
bins = bins,
domain = hex_grid_final$Total_Species
)
hex_grid_final <- st_transform(hex_grid_final, 4326)
# Leaflet Map
hexmap<-leaflet() %>%
addProviderTiles(providers$Esri.WorldImagery, group = "Satellite") %>%
# Add hexagons
addPolygons(data = hex_grid_final,
fillColor = ~pal_hex(Total_Species),
color = "black", weight = 0.5, opacity = 0.8,
fillOpacity = ~ifelse(Total_Species == 0, 0.4, 0.7),
popup = ~paste0(
"<b>Species Counts:</b><br>",
"Rat: ", Rat, "<br>",
"Mouse: ", Mouse, "<br>",
"Hedgehog: ", Hedgehog, "<br>",
"Possum: ", Possum, "<br>",
"Weasel: ", Weasel, "<br>",
"Stoat: ", Stoat, "<br>",
"Ferret: ", Ferret, "<br>",
"Rabbit: ", Rabbit, "<br>",
"<b>Total Selected Species:</b> ", Total_Species)) %>%
# Add legend
addLegend("bottomright", pal = pal_hex, values = hex_grid_final$Total_Species,
title = "Catches per Hex", opacity = 1)
sum(hex_grid_final$Total_Species)
# #Save each map
#   assign(paste0("hexmap_", y), hexmap)
#   message("Map created: hexmap_", y)
#
# }
library(htmlwidgets)
saveWidget(hexmap, "hexmap_2024.html", selfcontained = TRUE)
#hexmap
# hexmap_2020
# hexmap_2021
# hexmap_2022
# hexmap_2023
# hexmap_2024
# hexmap_2025
All_trap_records<-length(All_traps[[1]]) #need to change this from All_traps
All_catches<-length(catches_since_2020[[1]])
NumberTraps <- catches_since_2020 %>%
distinct(trap_id, .keep_all = TRUE)
trapLength <-length(NumberTraps[[1]])
NumberTraps <- catches_since_2020 %>%
distinct(trap_id, .keep_all = TRUE)
trapLength <-length(NumberTraps[[1]])
summary_stats <- list(
All_trap_records = length(All_traps[[1]]),
All_catches = length(catches_since_2020[[1]]),
trapLength = trapLength
)
write_json(summary_stats, "summary_stats.json", auto_unbox = TRUE)
#setwd("D:/PFWRA/R/practice_apps")
source("global.R")
library(plotly)
library(ggplot2)
library(bslib)
library(bsicons)
library(shiny)
library(leaflet)
library(rsconnect)
#loop though plot below for years
#next add a slider for date since fields in global
#creating multiple maps and plots/ totals for different date extents. :)
#update area once i get council data involved
#load hexmap_2024 html
#load sumary_stats.json
p <- ggplot(reduced_catches_since_2020, aes(x = Species, fill = Species)) +
geom_bar(color = "darkblue") +
geom_text(
stat = "count",
aes(label = ..count.., y = ..count..),
vjust = -0.2,
fontface = "bold"  # <- make the text bold
) +
scale_y_log10() +
xlab("") + ylab("") +
ggtitle("") +
theme_grey() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1, face = "bold", size = "11"),
axis.text.y = element_blank(),
axis.ticks.y = element_blank(),
legend.position = "none",
)
#ggplotly(p)
#
# value_box(
#   title = "Total Catches",
#   value = Catches_month,
#   showcase = bs_icon("pie-chart"),
#   theme = "purple"
# )
#
# value_box(
#   title = "Total Traps Checked",
#   value = reports_month,
#   showcase = bs_icon("graph-up"),
#   theme = "teal"
# )
#
# value_box(
#   title = "Total Traps Serviced",
#   value = trapLength_90,
#   showcase = bs_icon("bar-chart"),
#   theme = "pink"
# )
#
#
# navset_card_tab(
#   height = 450,
#   full_screen = TRUE,
#   title = "Catches last 90 days",
#   nav_panel(
#     "Bar Graph",
#     card_title("Species caught"),
#     ggplotly(p)
#   ),
#   nav_panel(
#     "Map",
#     card_title("Map of Aggregated Catches"),
#     hexMap
#   ),
#   nav_panel(
#     shiny::icon("circle-info"),
#     markdown("Learn more about [htmlwidgets](http://www.htmlwidgets.org/)")
#   )
# )
ui <- page_fillable(
layout_columns(
col_widths = c(9, 3),  # 3/4 and 1/4 layout
# Left column: tabset
navset_card_tab(
height = 450,
full_screen = TRUE,
title = tags$h2("Catches Since 2020"),
nav_panel(
"Map",
card_title("Map of Aggregated Catches"),
hexmap
),
nav_panel(
"Bar Graph",
card_title("Species caught"),
ggplotly(p)
),
),
# Right column: stacked value boxes
layout_column_wrap(
width = 1,
gap = "1rem",
value_box(
title = "Total Catches",
value = All_catches,
showcase = bs_icon("graph-up"),
theme = "purple"
),
value_box(
title = "Total Trap Services",
value = All_trap_records,
showcase = bs_icon("pie-chart"),
theme = "teal"
),
value_box(
title = "Total Traps Deployed",
value = trapLength,
showcase = bs_icon("bar-chart"),
theme = "pink"
)
)
)
)
server <- function(input, output, session) {}
print("Starting shiny app...")
shinyApp(ui, server)
saveWidget(p, "bar_chart_2024.html", selfcontained = TRUE)
library(htmlwidgets)
saveWidget(p, "bar_chart_2024.html", selfcontained = TRUE)
p <- ggplot(reduced_catches_since_2020, aes(x = Species, fill = Species)) +
geom_bar(color = "darkblue") +
geom_text(
stat = "count",
aes(label = ..count.., y = ..count..),
vjust = -0.2,
fontface = "bold"  # <- make the text bold
) +
scale_y_log10() +
xlab("") + ylab("") +
ggtitle("") +
theme_grey() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1, face = "bold", size = "11"),
axis.text.y = element_blank(),
axis.ticks.y = element_blank(),
legend.position = "none",
)
saveWidget(p, "bar_chart_2024.html", selfcontained = TRUE)
# Convert to plotly
p_plotly <- ggplotly(p)
saveWidget(p_plotly, "bar_chart_2024.html", selfcontained = TRUE)
shinyApp(ui, server)
