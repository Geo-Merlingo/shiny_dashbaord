adjusted_max <- if (max_val <= max(grade_template)) max(grade_template) + 1 else max_val + 1
# Final bins, ensuring monotonicity
bins <- unique(c(grade_template[grade_template < adjusted_max], adjusted_max))
# Build palette
pal_hex <- colorBin(
palette = c("#A9A9A9", "yellow", "orange", "red", "darkred")[1:(length(bins) - 1)],
bins = bins,
domain = hex_grid_final$Total_Species
)
hex_grid_final <- st_transform(hex_grid_final, 4326)
# Leaflet Map
hexmap<-leaflet() %>%
addProviderTiles(providers$Esri.WorldImagery, group = "Satellite") %>%
# Add hexagons
addPolygons(data = hex_grid_final,
fillColor = ~pal_hex(Total_Species),
color = "black", weight = 0.5, opacity = 0.8,
fillOpacity = ~ifelse(Total_Species == 0, 0.4, 0.7),
popup = ~paste0(
"<b>Species Counts:</b><br>",
"Rat: ", Rat, "<br>",
"Mouse: ", Mouse, "<br>",
"Hedgehog: ", Hedgehog, "<br>",
"Possum: ", Possum, "<br>",
"Weasel: ", Weasel, "<br>",
"Stoat: ", Stoat, "<br>",
"Ferret: ", Ferret, "<br>",
"Rabbit: ", Rabbit, "<br>",
"<b>Total Selected Species:</b> ", Total_Species)) %>%
# Add legend
addLegend("bottomright", pal = pal_hex, values = hex_grid_final$Total_Species,
title = "Catches per Hex", opacity = 1)
hex_size <- (st_bbox(areas)[4] - st_bbox(areas)[2]) / 20  # 100 hexagons fit in latitude range
sf_use_s2(FALSE)
areas <- st_make_valid(areas)
# Create a hexagonal grid over the study area
hex_grid <- st_make_grid(areas, cellsize = hex_size, what = "polygons", square = FALSE)
# Convert to sf object and give each hex an ID
hex_grid <- st_sf(hex_id = 1:length(hex_grid), geometry = hex_grid)
#  Clip hexagons to fit inside study area
hex_grid <- st_intersection(hex_grid, areas)
#  Ensure hex grid has same CRS as catch points
hex_grid <- st_transform(hex_grid, crs = st_crs(catches_count))
#  Assign each catch point to the nearest hexagon
nearest_hex <- st_nearest_feature(catches_count, hex_grid)
catches_count$hex_id <- hex_grid$hex_id[nearest_hex]
# Optional check: total count before aggregation
sum(catches_count$Count)
# Aggregate counts by hex + species
hex_counts <- catches_count %>%
group_by(hex_id, Species) %>%
summarise(Species_Count = sum(Count, na.rm = TRUE), .groups = "drop") %>%
st_drop_geometry()
# Check: does the sum look right?
sum(hex_counts$Species_Count)
# Diagnostic: check for duplicate hex_id rows (likely caused by geometry intersections)
hex_grid %>%
count(hex_id) %>%
filter(n > 1) -> check
# üõ†Ô∏è Fix: Deduplicate hex_grid so that each hex_id is unique (important before joining)
hex_grid_union <- hex_grid %>%
group_by(hex_id) %>%
summarise(geometry = st_union(geometry), .groups = "drop")
# Reproject to projected CRS for safe union
# hex_grid_union <- hex_grid %>%
#   st_transform(2193) %>%
#   group_by(hex_id) %>%
#   summarise(geometry = st_union(geometry), .groups = "drop") %>%
#   st_transform(4326)  # Return to WGS84 for leaflet
#  Pivot counts wider to make one row per hex
hex_counts_wide <- hex_counts %>%
pivot_wider(names_from = Species, values_from = Species_Count, values_fill = 0)
#  Join counts back to hex grid (now with one row per hex_id)
hex_grid_final <- hex_grid_union %>%
left_join(hex_counts_wide, by = "hex_id")
#  Calculate total species per hex (cleaner column selection)
species_cols <- intersect(
c("Rat", "Mouse", "Possum", "Weasel", "Stoat", "Ferret", "Hedgehog", "Rabbit"),
names(hex_grid_final)
)
hex_grid_final <- hex_grid_final %>%
rowwise() %>%
mutate(Total_Species = sum(c_across(all_of(species_cols)), na.rm = TRUE)) %>%
ungroup()
# check species total hasn't changed
sum(hex_grid_final$Total_Species)  # This should now match `sum(hex_counts$Species_Count)`
# Ensure Total_Species is calculated
hex_grid_final <- hex_grid_final %>%
mutate(Total_Species = ifelse(is.na(Total_Species), 0, Total_Species))
# Define your grading template
grade_template <- c(0, 1, 10, 30, 50)
# Compute per-year max
max_val <- max(hex_grid_final$Total_Species, na.rm = TRUE)
if (max_val == 0) max_val <- 1  # safeguard
# Extend the grading template to fit max, without collapsing bins
adjusted_max <- if (max_val <= max(grade_template)) max(grade_template) + 1 else max_val + 1
# Final bins, ensuring monotonicity
bins <- unique(c(grade_template[grade_template < adjusted_max], adjusted_max))
# Build palette
pal_hex <- colorBin(
palette = c("#A9A9A9", "yellow", "orange", "red", "darkred")[1:(length(bins) - 1)],
bins = bins,
domain = hex_grid_final$Total_Species
)
hex_grid_final <- st_transform(hex_grid_final, 4326)
# Leaflet Map
hexmap<-leaflet() %>%
addProviderTiles(providers$Esri.WorldImagery, group = "Satellite") %>%
# Add hexagons
addPolygons(data = hex_grid_final,
fillColor = ~pal_hex(Total_Species),
color = "black", weight = 0.5, opacity = 0.8,
fillOpacity = ~ifelse(Total_Species == 0, 0.4, 0.7),
popup = ~paste0(
"<b>Species Counts:</b><br>",
"Rat: ", Rat, "<br>",
"Mouse: ", Mouse, "<br>",
"Hedgehog: ", Hedgehog, "<br>",
"Possum: ", Possum, "<br>",
"Weasel: ", Weasel, "<br>",
"Stoat: ", Stoat, "<br>",
"Ferret: ", Ferret, "<br>",
"Rabbit: ", Rabbit, "<br>",
"<b>Total Selected Species:</b> ", Total_Species)) %>%
# Add legend
addLegend("bottomright", pal = pal_hex, values = hex_grid_final$Total_Species,
title = "Catches per Hex", opacity = 1)
#Mapping 'reduced_catches_since_2020'
#for running all years:
# for (y in 2020:2025) {
#   message("Processing year: ", y)
#
#   # Step 1: Get data
#   catches_count <- get(paste0("catches_count_", y))
#removed this here as a work around to remove warnings re crs type for funtion
# catches_count <- st_transform(catches_count, crs = 4326)
#for running one year
catches_count<-catches_count_2020
# Extract Longitude and Latitude
catches_count <- catches_count %>%
mutate(Longitude = st_coordinates(.)[,1],  # Extract Longitude (X)
Latitude = st_coordinates(.)[,2])   # Extract Latitude (Y)
# Create a color palette based on species
pal <- colorFactor(palette = "viridis", domain = catches_count$Species)
# High-contrast color palette
pal <- colorFactor(palette = "Dark2", domain = catches_count$Species)
# Example: Color based on a numeric or categorical variable (replace "YourAttribute" with an actual column)
pal_areas <- colorFactor(palette = "Set1", domain = areas$CustomerNa)
#change this to change the hex sizes
hex_size <- (st_bbox(areas)[4] - st_bbox(areas)[2]) / 30  # 100 hexagons fit in latitude range
sf_use_s2(FALSE)
areas <- st_make_valid(areas)
# Create a hexagonal grid over the study area
hex_grid <- st_make_grid(areas, cellsize = hex_size, what = "polygons", square = FALSE)
# Convert to sf object and give each hex an ID
hex_grid <- st_sf(hex_id = 1:length(hex_grid), geometry = hex_grid)
#  Clip hexagons to fit inside study area
hex_grid <- st_intersection(hex_grid, areas)
#  Ensure hex grid has same CRS as catch points
hex_grid <- st_transform(hex_grid, crs = st_crs(catches_count))
#  Assign each catch point to the nearest hexagon
nearest_hex <- st_nearest_feature(catches_count, hex_grid)
catches_count$hex_id <- hex_grid$hex_id[nearest_hex]
# Optional check: total count before aggregation
sum(catches_count$Count)
# Aggregate counts by hex + species
hex_counts <- catches_count %>%
group_by(hex_id, Species) %>%
summarise(Species_Count = sum(Count, na.rm = TRUE), .groups = "drop") %>%
st_drop_geometry()
# Check: does the sum look right?
sum(hex_counts$Species_Count)
# Diagnostic: check for duplicate hex_id rows (likely caused by geometry intersections)
hex_grid %>%
count(hex_id) %>%
filter(n > 1) -> check
# üõ†Ô∏è Fix: Deduplicate hex_grid so that each hex_id is unique (important before joining)
hex_grid_union <- hex_grid %>%
group_by(hex_id) %>%
summarise(geometry = st_union(geometry), .groups = "drop")
# Reproject to projected CRS for safe union
# hex_grid_union <- hex_grid %>%
#   st_transform(2193) %>%
#   group_by(hex_id) %>%
#   summarise(geometry = st_union(geometry), .groups = "drop") %>%
#   st_transform(4326)  # Return to WGS84 for leaflet
#  Pivot counts wider to make one row per hex
hex_counts_wide <- hex_counts %>%
pivot_wider(names_from = Species, values_from = Species_Count, values_fill = 0)
#  Join counts back to hex grid (now with one row per hex_id)
hex_grid_final <- hex_grid_union %>%
left_join(hex_counts_wide, by = "hex_id")
#  Calculate total species per hex (cleaner column selection)
species_cols <- intersect(
c("Rat", "Mouse", "Possum", "Weasel", "Stoat", "Ferret", "Hedgehog", "Rabbit"),
names(hex_grid_final)
)
hex_grid_final <- hex_grid_final %>%
rowwise() %>%
mutate(Total_Species = sum(c_across(all_of(species_cols)), na.rm = TRUE)) %>%
ungroup()
# check species total hasn't changed
sum(hex_grid_final$Total_Species)  # This should now match `sum(hex_counts$Species_Count)`
# Ensure Total_Species is calculated
hex_grid_final <- hex_grid_final %>%
mutate(Total_Species = ifelse(is.na(Total_Species), 0, Total_Species))
# Define your grading template
grade_template <- c(0, 1, 10, 30, 50)
# Compute per-year max
max_val <- max(hex_grid_final$Total_Species, na.rm = TRUE)
if (max_val == 0) max_val <- 1  # safeguard
# Extend the grading template to fit max, without collapsing bins
adjusted_max <- if (max_val <= max(grade_template)) max(grade_template) + 1 else max_val + 1
# Final bins, ensuring monotonicity
bins <- unique(c(grade_template[grade_template < adjusted_max], adjusted_max))
# Build palette
pal_hex <- colorBin(
palette = c("#A9A9A9", "yellow", "orange", "red", "darkred")[1:(length(bins) - 1)],
bins = bins,
domain = hex_grid_final$Total_Species
)
hex_grid_final <- st_transform(hex_grid_final, 4326)
# Leaflet Map
hexmap<-leaflet() %>%
addProviderTiles(providers$Esri.WorldImagery, group = "Satellite") %>%
# Add hexagons
addPolygons(data = hex_grid_final,
fillColor = ~pal_hex(Total_Species),
color = "black", weight = 0.5, opacity = 0.8,
fillOpacity = ~ifelse(Total_Species == 0, 0.4, 0.7),
popup = ~paste0(
"<b>Species Counts:</b><br>",
"Rat: ", Rat, "<br>",
"Mouse: ", Mouse, "<br>",
"Hedgehog: ", Hedgehog, "<br>",
"Possum: ", Possum, "<br>",
"Weasel: ", Weasel, "<br>",
"Stoat: ", Stoat, "<br>",
"Ferret: ", Ferret, "<br>",
"Rabbit: ", Rabbit, "<br>",
"<b>Total Selected Species:</b> ", Total_Species)) %>%
# Add legend
addLegend("bottomright", pal = pal_hex, values = hex_grid_final$Total_Species,
title = "Catches per Hex", opacity = 1)
#change this to change the hex sizes
hex_size <- (st_bbox(areas)[4] - st_bbox(areas)[2]) / 40  # 100 hexagons fit in latitude range
sf_use_s2(FALSE)
areas <- st_make_valid(areas)
# Create a hexagonal grid over the study area
hex_grid <- st_make_grid(areas, cellsize = hex_size, what = "polygons", square = FALSE)
# Convert to sf object and give each hex an ID
hex_grid <- st_sf(hex_id = 1:length(hex_grid), geometry = hex_grid)
#  Clip hexagons to fit inside study area
hex_grid <- st_intersection(hex_grid, areas)
#  Ensure hex grid has same CRS as catch points
hex_grid <- st_transform(hex_grid, crs = st_crs(catches_count))
#  Assign each catch point to the nearest hexagon
nearest_hex <- st_nearest_feature(catches_count, hex_grid)
catches_count$hex_id <- hex_grid$hex_id[nearest_hex]
# Optional check: total count before aggregation
sum(catches_count$Count)
# Aggregate counts by hex + species
hex_counts <- catches_count %>%
group_by(hex_id, Species) %>%
summarise(Species_Count = sum(Count, na.rm = TRUE), .groups = "drop") %>%
st_drop_geometry()
# Check: does the sum look right?
sum(hex_counts$Species_Count)
# Diagnostic: check for duplicate hex_id rows (likely caused by geometry intersections)
hex_grid %>%
count(hex_id) %>%
filter(n > 1) -> check
# üõ†Ô∏è Fix: Deduplicate hex_grid so that each hex_id is unique (important before joining)
hex_grid_union <- hex_grid %>%
group_by(hex_id) %>%
summarise(geometry = st_union(geometry), .groups = "drop")
# Reproject to projected CRS for safe union
# hex_grid_union <- hex_grid %>%
#   st_transform(2193) %>%
#   group_by(hex_id) %>%
#   summarise(geometry = st_union(geometry), .groups = "drop") %>%
#   st_transform(4326)  # Return to WGS84 for leaflet
#  Pivot counts wider to make one row per hex
hex_counts_wide <- hex_counts %>%
pivot_wider(names_from = Species, values_from = Species_Count, values_fill = 0)
#  Join counts back to hex grid (now with one row per hex_id)
hex_grid_final <- hex_grid_union %>%
left_join(hex_counts_wide, by = "hex_id")
#  Calculate total species per hex (cleaner column selection)
species_cols <- intersect(
c("Rat", "Mouse", "Possum", "Weasel", "Stoat", "Ferret", "Hedgehog", "Rabbit"),
names(hex_grid_final)
)
hex_grid_final <- hex_grid_final %>%
rowwise() %>%
mutate(Total_Species = sum(c_across(all_of(species_cols)), na.rm = TRUE)) %>%
ungroup()
# check species total hasn't changed
sum(hex_grid_final$Total_Species)  # This should now match `sum(hex_counts$Species_Count)`
# Ensure Total_Species is calculated
hex_grid_final <- hex_grid_final %>%
mutate(Total_Species = ifelse(is.na(Total_Species), 0, Total_Species))
# Define your grading template
grade_template <- c(0, 1, 10, 30, 50)
# Compute per-year max
max_val <- max(hex_grid_final$Total_Species, na.rm = TRUE)
if (max_val == 0) max_val <- 1  # safeguard
# Extend the grading template to fit max, without collapsing bins
adjusted_max <- if (max_val <= max(grade_template)) max(grade_template) + 1 else max_val + 1
# Final bins, ensuring monotonicity
bins <- unique(c(grade_template[grade_template < adjusted_max], adjusted_max))
# Build palette
pal_hex <- colorBin(
palette = c("#A9A9A9", "yellow", "orange", "red", "darkred")[1:(length(bins) - 1)],
bins = bins,
domain = hex_grid_final$Total_Species
)
hex_grid_final <- st_transform(hex_grid_final, 4326)
# Leaflet Map
hexmap<-leaflet() %>%
addProviderTiles(providers$Esri.WorldImagery, group = "Satellite") %>%
# Add hexagons
addPolygons(data = hex_grid_final,
fillColor = ~pal_hex(Total_Species),
color = "black", weight = 0.5, opacity = 0.8,
fillOpacity = ~ifelse(Total_Species == 0, 0.4, 0.7),
popup = ~paste0(
"<b>Species Counts:</b><br>",
"Rat: ", Rat, "<br>",
"Mouse: ", Mouse, "<br>",
"Hedgehog: ", Hedgehog, "<br>",
"Possum: ", Possum, "<br>",
"Weasel: ", Weasel, "<br>",
"Stoat: ", Stoat, "<br>",
"Ferret: ", Ferret, "<br>",
"Rabbit: ", Rabbit, "<br>",
"<b>Total Selected Species:</b> ", Total_Species)) %>%
# Add legend
addLegend("bottomright", pal = pal_hex, values = hex_grid_final$Total_Species,
title = "Catches per Hex", opacity = 1)
sum(hex_grid_final$Total_Species)
# #Save each map
#   assign(paste0("hexmap_", y), hexmap)
#   message("Map created: hexmap_", y)
#
# }
saveWidget(hexmap, "data/hexmap.html", selfcontained = TRUE)
# st_write(hex_grid_final, "data/hex_grid.shp", append = TRUE)
#hexmap
# hexmap_2020
# hexmap_2021
# hexmap_2022
# hexmap_2023
# hexmap_2024
# hexmap_2025
# All_trap_records<-length(All_traps[[1]]) #need to change this from All_traps
# All_catches<-length(catches_since_2020[[1]])
NumberTraps <- catches_since_2020 %>%
distinct(trap_id, .keep_all = TRUE)
summary_stats <- list(
All_trap_records = length(All_traps[[1]]),
All_catches = length(catches_since_2020[[1]]),
trapLength <-length(NumberTraps[[1]])
)
All_trap_records = length(All_traps[[1]])
All_catches = length(catches_since_2020[[1]])
trapLength <-length(NumberTraps[[1]])
jsonlite::write_json(summary_stats, "data/summary_stats.json", auto_unbox = TRUE)
count_data <- reduced_catches_since_2020 %>%
count(Species)
p <- ggplot(count_data, aes(x = Species, y = n, fill = Species)) +
geom_col(color = "darkblue") +
geom_text(aes(label = n), vjust = -0.2, fontface = "bold", size = 4) +
scale_y_log10() +
xlab("") + ylab("") +
ggtitle("") +
theme_grey() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1, face = "bold", size = 11),
axis.text.y = element_blank(),
axis.ticks.y = element_blank(),
legend.position = "none",
panel.grid.major.x = element_blank(),
panel.grid.minor.x = element_blank()
)
print(p)
# # Save the plot as a PNG first
# ggsave("data/bar_chart.png", p, width = 8, height = 5, dpi = 300, bg = "transparent")
#
# # Create simple HTML
# htmltools::save_html(
#   tags$html(
#     tags$body(
#       tags$img(src = "bar_chart.png", style = "width:100%; max-width:800px;")
#     )
#   ),
#   file = "data/bar_chart.html"
# )
#saveWidget(p_plotly, "data/bar_chart_2024.html", selfcontained = TRUE)
#jsonlite::write_json(totals, "data/totals.json", auto_unbox = TRUE)
hexmap
ui <- page_fillable(
layout_columns(
col_widths = c(9, 3),
navset_card_tab(
height = 450,
full_screen = TRUE,
title = tags$h2("Catches Since 2020"),
nav_panel(
"Map",
card_title("Map of Aggregated Catches"),
hexmap
),
nav_panel(
"Bar Graph",
card_title("Species caught"),
plotOutput("bar_plot")  # a placeholder in the UI
)
),
layout_column_wrap(
width = 1,
gap = "1rem",
value_box(
title = "Total Catches",
value = All_catches,
showcase = bs_icon("graph-up"),
theme = "purple"
),
value_box(
title = "Total Trap Services",
value = All_trap_records,
showcase = bs_icon("pie-chart"),
theme = "teal"
),
value_box(
title = "Total Traps Deployed",
value = trapLength,
showcase = bs_icon("bar-chart"),
theme = "pink"
)
)
)
)
server <- function(input, output, session) {
output$bar_plot <- renderPlot({
p   # your ggplot object (e.g., created with ggplot(catches_data, aes(...)))
})
}
print("Starting shiny app...")
shinyApp(ui, server)
setwd("D:/PFWRA/R/practice_apps")
source("global.R")
library(plotly)
library(ggplot2)
library(bslib)
library(bsicons)
library(shiny)
library(leaflet)
library(rsconnect)
library(htmlwidgets)
#loop though plot below for years
#next add a slider for date since fields in global
#creating multiple maps and plots/ totals for different date extents. :)
ui <- page_fillable(
layout_columns(
col_widths = c(9, 3),
navset_card_tab(
height = 450,
full_screen = TRUE,
title = tags$h2("Catches Since 2020"),
nav_panel(
"Map",
card_title("Map of Aggregated Catches"),
hexmap
),
nav_panel(
"Bar Graph",
card_title("Species caught"),
plotOutput("bar_plot")  # a placeholder in the UI
)
),
layout_column_wrap(
width = 1,
gap = "1rem",
value_box(
title = "Total Catches",
value = All_catches,
showcase = bs_icon("graph-up"),
theme = "purple"
),
value_box(
title = "Total Trap Services",
value = All_trap_records,
showcase = bs_icon("pie-chart"),
theme = "teal"
),
value_box(
title = "Total Traps Deployed",
value = trapLength,
showcase = bs_icon("bar-chart"),
theme = "pink"
)
)
)
)
server <- function(input, output, session) {
output$bar_plot <- renderPlot({
p   # your ggplot object (e.g., created with ggplot(catches_data, aes(...)))
})
}
print("Starting shiny app...")
shinyApp(ui, server)
